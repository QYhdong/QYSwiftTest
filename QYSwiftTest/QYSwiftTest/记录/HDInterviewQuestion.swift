//
//  HDInterviewQuestion.swift
//  QYSwiftTest
//
//  Created by HJddd on 2018/10/29.
//  Copyright © 2018年 HuangDong. All rights reserved.
//

/*
 
 
 ms
 
 •    iOS事件传递及响应者链条： 1.当iOS程序中发生触摸事件后，系统会将事件加入到UIApplication管理的一个任务队列中 2.UIApplication将处于任务队列最前端的事件向下分发。即UIWindow。 3.UIWindow将事件向下分发，即UIView。 4.UIView首先看自己是否能处理事件，触摸点是否在自己身上。如果能，那么继续寻找子视图。 5.遍历子控件，重复以上两步。 6.如果没有找到，那么自己就是事件处理者。如果 7.如果自己不能处理，那么不做任何处理。
 •    kvo和kvc是什么
 KVC的本质就是 (键值编码), 定义: 在对象创建完成之后,动态(牵扯到运行时)的给对象的属性赋值，即是指 NSKeyValueCoding，一个非正式的Protocol，提供一种机制来间接访问对象的属性。而不是通过调用Setter、Getter方法访问。
 KVO 的本质就是(键值监听), 定义::Key-Value Observing,它提供一种机制,当指定的对象的属性被修改后,则对象就会接受到通知。
 KVO 是基于 runtime 机制实现的 当某个类的属性对象第一次被观察时，系统就会运行期动态地创建该类的一 个派生类，在这个派生类中重写基类中任何被观察属性的 setter 方法。派生类在 被重写的 setter 方法内实现真正的通知机制  如果原类为 Person，那么生成的派生类名为 NSKVONotifying_Person 每个类对象中都有一个 isa 指针指向当前类，当一个类对象的第一次被观察，那么 系统会偷偷将 isa 指针指向动态生成的派生类，从而在给被监控属性赋值时执行的 是派生类的 setter 方法  键值观察通知依赖于 NSObject 的两个方法 : willChangeValueForKey: 和 didChangevlueForKey:;在一个被观察属性发生改变之前， willChangeValueForKey: 一定会被调用，这就 会记录旧的值。而当改变发生后，didChangeValueForKey: 会 被调用，继而 observeValueForKey:ofObject:change:context: 也会被调用。 补充:KVO 的这套实现机制中苹果还偷偷重写了 class 方法，让我们误认为还是使 用的当前类，从而达到隐藏生成的派生类  
 •    问对内存管理的了解
 ObjC采用引用计数（reference counting）的技术来进行管理： 　　　　1）每个对象都有一个关联的整数，称为引用计数器 　　　　2）当代码需要使用该对象时，则将对象的引用计数加1 　　　　3）当代码结束使用该对象时，则将对象的引用计数减1 　　　　4）当引用计数的值变为0时，表示对象没有被任何代码使用，此时对象将被释放。
 　　　　与之对应的消息发送方法如下：
 　　　　　　　　1）当对象被创建（通过alloc、new或copy等方法）时，其引用计数初始值为1 　　　　2）給对象发送retain消息，其引用计数加1 　　　　3）給对象发送release消息，其引用计数减1 　　　　4）当对象引用计数归0时，ObjC給对象发送dealloc消息销毁对象
 
 •    strong和copy的区别
 strong 与copy都会使引用计数加1，但strong是两个指针指向同一个内存地址，copy会在内存里拷贝一份对象，两个指针指向不同的内存地址
 •    assign和weak的区别
 assign适用于基本数据类型，weak是适用于NSObject对象，并且是一个弱引用。
 assign其实也可以用来修饰对象。那么我们为什么不用它修饰对象呢？因为被assign修饰的对象（一般编译的时候会产生警告：Assigning retained object to unsafe property; object will be released after assignment）在释放之后，指针的地址还是存在的，也就是说指针并没有被置为nil，造成野指针。对象一般分配在堆上的某块内存，如果在后续的内存分配中，刚好分到了这块地址，程序就会崩溃掉。
 那为什么可以用assign修饰基本数据类型？因为基础数据类型一般分配在栈上，栈的内存会由系统自己自动处理，不会造成野指针。
 weak修饰的对象在释放之后，指针地址会被置为nil。所以现在一般弱引用就是用weak。weak使用场景：
 在ARC下,在有可能出现循环引用的时候，往往要通过让其中一端使用weak来解决，比如: delegate代理属性，通常就会声明为weak。
 自身已经对它进行一次强引用，没有必要再强引用一次时也会使用weak。比如：自定义 IBOutlet控件属性一般也使用weak，当然也可以使用strong。
 •    进程和线程
 线程和进程的关系:
 进程和应用程序的关系：进程为应用程序开辟内存空间；
 线程和应用程序的关系：线程执行应用程序的代码；
 进程和线程之间的关系：进程是由线程组成的、一个进程理论上可以有很多个线程、但至少有一个主线程；
 在iOS中进程相关的操作并不是很多，常见的就App之间相互调用，苹果公司将这些操作都封装在了UIApplcation这个类中了。
 •    categoty作用
 不需要通过增加子类而增加现有类的行为(方法),且类目中的方法与原始类方法基本没有区别;
 通过类目可以将庞大一个类的方法进行划分,从而便于代码的日后的维护、更新以及提高代码的阅读性; 但无法添加属性 可通过runtime添加.
 •    对protocol的理解
 官方文档翻译:
 协议声明了任何类可以选择实现的编程接口。 协议使得通过继承远程相关的两个类可以相互通信以实现某个目标。 因此，他们提供了子类化的替代方案。 任何可以提供对其他类有用的行为的类都可以声明一个编程接口，用于匿名出售该行为。 任何其他类可以选择采用协议并实现其一个或多个方法，从而利用该行为。 声明协议的类如果由协议采用者实现，则期望调用协议中的方法。
 
 
 •    swift中的一些访问修饰符
 private
 修饰的属性或者方法只能在当前类里面访问。
  fileprivate
 访问级别所修饰的属性或者方法在当前的Swift源文件里可以访问
    internal
 访问级别所修饰的属性或方法在源代码所在的整个模块都可以访问。  如果是框架或者库代码，则在整个框架内部都可以访问，框架由外部代码所引用时，则不可以访问。 如果是App代码，也是整个App代码，也是在整个App内部都可以访问。
 public      可以被任何人访问，但是在其他module中不可以被重写和继承，而在本module中可以重写和继承
 
 open  可以任何人使用，包括重写和继承。
 •    SDWebImage原理
 
 •    Swift中@objc的使用
 
 •    Block使用时的注意事项
 
 •    swift中try？和try！的区别
 try?会将错误转换为可选值，当调用try?＋函数或方法语句时候，如果函数或方法抛出错误，程序不会发崩溃，而返回一个nil，如果没有抛出错误则返回可选值。
 使用try!可以打破错误传播链条。错误抛出后传播给它的调用者，这样就形成了一个传播链条，但有的时候确实不想让错误传播下去，可以使用try!语句,告诉系统确保没有问题,有问题则崩溃。
 •    代理可以使用assign修饰吗
 
 •    block中为什么使用weak修饰self
 
 •    AFN原理 内部类方法
 
 •    Sql语句
 
 •    无限循环轮播的实现
 
 •    WKWebview和UIWebview相比做的优化有哪些
 •    UIWebView具体实现过程,以及一些优化的实现
 •    tableView优化
 •    HTTP和HTTPS有什么不同
 •    Get和post的使用特点
 •    Tcp三次握手和四次挥手
 •    图片压缩方式
 •    开发中遇到的一些技术难点
 •    ios消息转发机制
 •    哈希算法
 •    时间复杂度
 •    二叉树

 
 */
